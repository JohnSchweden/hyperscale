---
phase: 02-swipe-interactions
plan: 02
type: execute
wave: 1
depends_on:
  - 02-01
files_modified:
  - App.tsx
autonomous: true
must_haves:
  truths:
    - "Next card is visible underneath current card during swipe"
    - "Card stack shows depth with scale and opacity (0.95, 0.6)"
    - "Gradient preview scales with swipe distance"
    - "Text label scales from 0.5 to 1.0 as swipe progresses"
    - "Preview appears after 50px swipe threshold"
  artifacts:
    - path: "App.tsx"
      provides: "Card stack rendering and enhanced swipe preview"
      exports: ["renderGame"]
  key_links:
    - from: "renderGame card container"
      to: "next card pre-render"
      via: "z-index layering with scale/opacity"
    - from: "swipeOffset state"
      to: "gradient/label scale"
      via: "dynamic CSS transform calculations"
---

## Objective

Implement the card stack structure showing the next card underneath, and enhance the swipe preview with distance-scaled gradients and text labels. Update App.tsx renderGame() method with new card stack DOM structure and dynamic preview scaling.

**Purpose:** Create the "deck" feel showing progression, and make swipe decisions more intuitive with contextual labels that scale with swipe distance.

**Output:** Updated App.tsx with card stack rendering, next card pre-rendering, and enhanced swipe preview with dynamic scaling.

## Execution Context

@/Users/yevgenschweden/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/yevgenschweden/.config/opencode/get-shit-done/templates/summary.md

## Context

@/Users/yevgenschweden/hyperscale/.planning/PROJECT.md
@/Users/yevgenschweden/hyperscale/.planning/ROADMAP.md
@/Users/yevgenschweden/hyperscale/.planning/STATE.md
@/Users/yevgenschweden/hyperscale/.planning/phases/02-swipe-interactions/02-CONTEXT.md
@/Users/yevgenschweden/hyperscale/.planning/phases/02-swipe-interactions/02-01-SUMMARY.md

@/Users/yevgenschweden/hyperscale/App.tsx

### Current Implementation

Current renderGame() card structure (lines 570-649):
- Single card container with ref={cardRef}
- Swipe preview overlay shows at SWIPE_PREVIEW_THRESHOLD (50px)
- Current preview: Static gradient + text label at fixed opacity (0.5)
- No next card rendering

### Requirements from CONTEXT.md

**SWIPE-03: Card stack showing next card**
- Next card rendered behind current card with z-index: 0
- Scale: 0.95, Opacity: 0.6 for depth effect
- Same size and dimensions as current card
- Creates "deck" feel showing progression

**SWIPE-04: Enhanced gradient/text swipe preview**
- Red gradient overlay when swiping left (scales with distance)
- Green gradient overlay when swiping right (scales with distance)
- Text label scales from 0.5 to 1.0 with swipe distance
- Appears when swipe exceeds 50px (SWIPE_PREVIEW_THRESHOLD)
- NO generic icons â€” contextual labels only ("DEBUG", "PASTE", etc.)
- Card opacity does NOT fade during swipe (keep text readable)

**Scale calculation:**
- Base scale at threshold (50px): 0.5
- Max scale at full threshold (100px): 1.0
- Linear interpolation: scale = 0.5 + (Math.abs(swipeOffset) - 50) / 50 * 0.5

## Tasks

<task type="auto">
  <name>Task 1: Create card stack container structure</name>
  <files>App.tsx</files>
  <action>
    Refactor the card rendering in renderGame() to support a card stack with next card visible underneath.

    Current structure (around line 570):
    ```tsx
    <div
      ref={cardRef}
      className={`flex-1 w-full max-w-full...`}
      ...touch handlers...
    >
      {/* Current card content */}
    </div>
    ```

    New structure needed:
    ```tsx
    <div className="relative flex-1 w-full max-w-full lg:max-w-[43rem]">
      {/* Next card (behind) - render only if there's a next card */}
      {state.currentCardIndex + 1 < cards.length && (
        <div 
          className="absolute inset-0 bg-slate-900/90 border border-slate-700 rounded-xl overflow-hidden shadow-2xl flex flex-col"
          style={{
            zIndex: 0,
            transform: 'scale(0.95)',
            opacity: 0.6,
          }}
        >
          {/* Simplified next card content - just header and basic structure */}
          <div className="bg-slate-800 px-3 md:px-4 py-2 flex items-center justify-between border-b border-white/5">
            <div className="flex items-center gap-2 text-[10px] mono font-bold text-slate-400 truncate">
              <i className={`fa-solid ${nextCard.source === AppSource.IDE ? 'fa-terminal' : 'fa-hashtag'}`} aria-hidden></i>
              <span className="truncate">{nextCard.source} // {nextCard.context}</span>
            </div>
            <div className="flex gap-1.5 shrink-0">
              <div className="w-2.5 h-2.5 rounded-full bg-slate-600"></div>
              <div className="w-2.5 h-2.5 rounded-full bg-slate-600"></div>
              <div className="w-2.5 h-2.5 rounded-full bg-red-500/50"></div>
            </div>
          </div>
          <div className="p-4 md:p-10 flex flex-col justify-center items-center flex-1">
            <div className="text-slate-600 text-sm mono">Next incident loading...</div>
          </div>
        </div>
      )}

      {/* Current card (front) - existing card becomes this */}
      <div
        ref={cardRef}
        className={`relative flex-1 w-full... z-10 ...`}
        style={{...}}
      >
        {/* Existing card content */}
      </div>
    </div>
    ```

    Key changes:
    1. Wrap the existing card in a relative positioned container
    2. Add next card div BEFORE the current card (so it's behind in DOM order)
    3. Next card has: position absolute, z-index 0, scale(0.95), opacity 0.6
    4. Current card gets explicit z-index: 10
    5. Next card only renders if there's a next card (currentCardIndex + 1 < cards.length)
    6. Next card shows simplified content (header + "Next incident loading...")

    Get nextCard from: `const nextCard = cards[state.currentCardIndex + 1]`
    (safely check bounds before rendering)
  </action>
  <verify>
    grep -A 20 "Next card" App.tsx | head -25
    grep "z-index.*0" App.tsx
    grep "scale(0.95)" App.tsx
    grep "opacity.*0.6" App.tsx
  </verify>
  <done>
    - Card container is wrapped in relative positioned div
    - Next card renders behind current card with z-index: 0
    - Next card has scale(0.95) and opacity(0.6)
    - Current card has z-index: 10
    - Next card only renders when there IS a next card
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement dynamic preview scaling</name>
  <files>App.tsx</files>
  <action>
    Update the swipe preview overlay (lines 590-596) to scale gradient and text label based on swipe distance.

    Current preview (lines 590-596):
    ```tsx
    {swipeDirection && (
      <div className={`absolute inset-0 pointer-events-none z-10 ${swipeDirection === 'RIGHT' ? 'swipe-gradient-right' : 'swipe-gradient-left'}`}>
        <div className={`absolute top-1/2 -translate-y-1/2 ${swipeDirection === 'RIGHT' ? 'right-8' : 'left-8'} text-4xl md:text-6xl font-black tracking-tighter ${swipeDirection === 'RIGHT' ? 'text-green-500' : 'text-red-500'} opacity-50`}>
          {swipeDirection === 'RIGHT' ? currentCard.onRight.label.toUpperCase() : currentCard.onLeft.label.toUpperCase()}
        </div>
      </div>
    )}
    ```

    Update to use dynamic scaling based on swipeOffset:
    ```tsx
    {swipeDirection && (
      <div 
        className={`absolute inset-0 pointer-events-none z-10 ${swipeDirection === 'RIGHT' ? 'swipe-gradient-right' : 'swipe-gradient-left'}`}
        style={{
          opacity: Math.min(0.8, 0.3 + (Math.abs(swipeOffset) - SWIPE_PREVIEW_THRESHOLD) / SWIPE_THRESHOLD * 0.5),
        }}
      >
        <div 
          className={`absolute top-1/2 -translate-y-1/2 ${swipeDirection === 'RIGHT' ? 'right-8' : 'left-8'} font-black tracking-tighter ${swipeDirection === 'RIGHT' ? 'text-green-500' : 'text-red-500'}`}
          style={{
            fontSize: swipeDirection === 'RIGHT' 
              ? `clamp(1.5rem, ${2 + (Math.abs(swipeOffset) - SWIPE_PREVIEW_THRESHOLD) / SWIPE_THRESHOLD * 2}rem, 3.75rem)`
              : `clamp(1.5rem, ${2 + (Math.abs(swipeOffset) - SWIPE_PREVIEW_THRESHOLD) / SWIPE_THRESHOLD * 2}rem, 3.75rem)`,
            transform: `scale(${0.5 + Math.min(0.5, (Math.abs(swipeOffset) - SWIPE_PREVIEW_THRESHOLD) / SWIPE_THRESHOLD * 0.5)})`,
            opacity: 0.5 + Math.min(0.5, (Math.abs(swipeOffset) - SWIPE_PREVIEW_THRESHOLD) / SWIPE_THRESHOLD * 0.5),
          }}
        >
          {swipeDirection === 'RIGHT' ? currentCard.onRight.label.toUpperCase() : currentCard.onLeft.label.toUpperCase()}
        </div>
      </div>
    )}
    ```

    Key calculations:
    - Scale: 0.5 + (min(0.5, (abs(offset) - 50) / 50 * 0.5))
      - At 50px: 0.5
      - At 100px: 1.0
    - Opacity: 0.5 + (min(0.5, (abs(offset) - 50) / 50 * 0.5))
      - Same progression as scale

    Alternative simpler approach using CSS clamp:
    ```tsx
    const previewProgress = Math.min(1, Math.max(0, (Math.abs(swipeOffset) - SWIPE_PREVIEW_THRESHOLD) / (SWIPE_THRESHOLD - SWIPE_PREVIEW_THRESHOLD)));
    // Then use previewProgress for scale and opacity
    ```

    The gradient intensity should also scale - use inline style for opacity on the gradient div.
  </action>
  <verify>
    grep -A 15 "swipeDirection &&" App.tsx | head -20
    Should show dynamic style calculations with swipeOffset
    grep "previewProgress\|Math.abs(swipeOffset)" App.tsx | head -5
  </verify>
  <done>
    - Text label scales from 0.5 to 1.0 based on swipe distance
    - Label opacity increases from 0.5 to 1.0 with distance
    - Gradient opacity scales with distance (0.3 to 0.8)
    - All calculations use SWIPE_PREVIEW_THRESHOLD (50) and SWIPE_THRESHOLD (100)
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate spring snap-back transition</name>
  <files>App.tsx</files>
  <action>
    Update the card's transition style to use the spring physics class when snapping back (released under threshold).

    Current transition style (line 585):
    ```tsx
    transition: isDragging ? 'none' : 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)',
    ```

    Update to conditionally use spring class:
    ```tsx
    transition: isDragging 
      ? 'none' 
      : cardExitDirection 
        ? 'none'  // Exit animation uses CSS class, not inline
        : 'transform 0.55s cubic-bezier(0.34, 1.56, 0.64, 1)',  // Spring snap-back
    ```

    Or apply the spring class to the card element:
    ```tsx
    className={`... ${!isDragging && !cardExitDirection && swipeOffset !== 0 ? 'spring-snap-back' : ''} ...`}
    ```

    The key is: when the user releases (isDragging becomes false) and there's no exit direction (meaning they didn't cross threshold), the card should spring back with the bouncy animation.

    Also ensure handleTouchEnd properly resets swipeOffset to 0 when under threshold (this already exists in lines 174-177).
  </action>
  <verify>
    grep "cubic-bezier(0.34, 1.56" App.tsx
    OR
    grep "spring-snap-back" App.tsx
  </verify>
  <done>
    - Card uses spring physics (cubic-bezier 0.34, 1.56, 0.64, 1) when snapping back
    - Duration is 500-600ms
    - Only applies when releasing under threshold (no exit direction)
  </done>
</task>

## Verification

### Code Verification
- [ ] Next card renders with z-index 0, scale 0.95, opacity 0.6
- [ ] Current card has z-index 10
- [ ] Preview scales dynamically with swipeOffset
- [ ] Spring physics transition is applied for snap-back

### Behavior Verification
- [ ] Card stack is visible in DOM
- [ ] Next card shows behind current card
- [ ] Preview label scales as user swipes further
- [ ] TypeScript compiles without errors: `bun run build`

## Success Criteria

1. Card stack creates "deck" feel with next card visible underneath
2. Swipe preview scales smoothly from 0.5 to 1.0 as swipe progresses
3. Gradient intensity increases with swipe distance
4. Spring physics snap-back feels natural and bouncy
5. All existing functionality preserved (keyboard nav, touch, mouse)

## Output

After completion, create `.planning/phases/02-swipe-interactions/02-02-SUMMARY.md`
